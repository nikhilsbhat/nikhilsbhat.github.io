[
  {
    "categories": null,
    "contents": "Command-line interface for GoCD that helps in interacting with GoCD server.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/gocd-cli/",
    "tags": [
      "GoCD",
      "Go",
      "Golang",
      "Infrastructure",
      "CI-CD",
      "continuous-delivery",
      "cli",
      "continuous-integration",
      "command-line"
    ],
    "title": "Commandline interface for GoCD server"
  },
  {
    "categories": null,
    "contents": " This Library could be helpful while building any tools around GoCD or while interacting with GoCD to perform certain daily activities. Which could include checking the health of all agents connected to GoCD or status of a job and many more. ",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/gocd-sdk-golang/",
    "tags": [
      "GoCD",
      "Go",
      "Golang",
      "Infrastructure",
      "GoCD-API",
      "API",
      "GoCD-Server",
      "SDK",
      "Client-Library",
      "GoCD-SDK-GO"
    ],
    "title": "GoCD Golang SDK"
  },
  {
    "categories": null,
    "contents": " Prometheus exporter that helps in collecting various metadata and other information from GoCD and exposes it as metrics. This interacts with GoCD server's api to collect metrics, also monitors pipeline directories specified when deployed in GoCD server. It schedules both metric collections from GoCD server and pipeline size as cron to reduce resource spike when /metrics is invoked. Most importantly disk check is an expensive operation which can spike resource consumption, by doing this way load on the platform exporter is running can be reduced. ",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/gocd-prometheus-exporter/",
    "tags": [
      "GoCD",
      "Go",
      "Golang",
      "Infrastructure",
      "Prometheus",
      "Prometheus-exporter",
      "GoCD-Server",
      "Kubernetes"
    ],
    "title": "GoCD prometheus exporter"
  },
  {
    "categories": null,
    "contents": "A terraform provider for GoCD that helps in performing tasks on GoCD server.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/terraform-provider-gocd/",
    "tags": [
      "Terraform",
      "Go",
      "Golang",
      "Infrastructure",
      "CI-CD",
      "continuous-delivery",
      "continuous-integration",
      "command-line",
      "GoCD",
      "k3s",
      "terraform-provider",
      "terraform-custom-provider"
    ],
    "title": "GoCD Terraform Provider"
  },
  {
    "categories": null,
    "contents": " The helm plugin that helps in identifying deviations(mostly due to in-place edits) in the configurations that are deployed via helm chart. Kubernetes' resources can be deployed via package manager helm, it is easier to deploy but to manage the same require more effort.  If helm is used, strictly all resources should be managed by helm itself, but there are places where manual interventions are needed. This results in configuration drift from helm charts deployed. These changes can be overridden by next helm release, what if the required changes are lost before adding it back to helm chart?  This helm plugin is intended to solve the same problem by validating the resources that are part of appropriate chart/release against kubernetes.  This leverages kubectl diff to identify the drifts.  ",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/helm-drift/",
    "tags": [
      "Helm",
      "Go",
      "Golang",
      "Infrastructure",
      "Helm-Plugins",
      "Helm-Extensions",
      "Helm-Drift",
      "Drift",
      "Registry"
    ],
    "title": "Helm Drift"
  },
  {
    "categories": null,
    "contents": " Identifying all images just before the deployment of the helm chart is not a straightforward task.  To make it simple, the helm plugin is leveraged. This can be installed as an add-on to the helm.  It helps in filtering images based on the Kubernetes type. It also helps in filtering images based on a registry which it is part of.  ",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/helm-images/",
    "tags": [
      "Helm",
      "Go",
      "Golang",
      "Infrastructure",
      "Helm-Plugins",
      "Helm-Extensions",
      "Helm-Images",
      "Images",
      "Registry"
    ],
    "title": "Helm Images"
  },
  {
    "categories": null,
    "contents": "A terraform provider support for k3d, which helps in performing all operation that k3d does.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/terraform-provider-k3d/",
    "tags": [
      "Terraform",
      "Go",
      "Golang",
      "Infrastructure",
      "rancher",
      "k3d",
      "docker",
      "containerd",
      "k3s",
      "terraform-provider",
      "terraform-custom-provider"
    ],
    "title": "k3d Terraform Provider"
  },
  {
    "categories": null,
    "contents": "Terraform is one of the best software available to automate the infrastructure and no procrastination in accepting that.\nExtending terraform would help in solving more complexities. Terragen generates defined templates to ease the creation of terraform custom provider which will help in extending terraform.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/terragen/",
    "tags": [
      "Terraform",
      "Go",
      "Infrastructure"
    ],
    "title": "Terragen"
  },
  {
    "categories": null,
    "contents": "This the backbone of neuron cli and is responsible for conneccting to various cloud from a single cloud.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/neuron-cloudy/",
    "tags": [
      "GoLang",
      "AWS",
      "AZURE",
      "GCP",
      "REST APIs",
      "Go"
    ],
    "title": "Neuron Cloudy"
  },
  {
    "categories": null,
    "contents": "In the current era of Devops, with the growing list of tools which one have to deal with to automate the day to day tasks in their respective projects is quite challenging.\nLearning new cloud platform brings in its own challenges with it, one has to learn its natvie terminologies of calling the same resurce. Seeing all these started working on Neuron.\nNo need to know the names of the resources in different cloud. Single tool which can provision cloud resources as per the requirement.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/neuron/",
    "tags": [
      "GoLang",
      "AWS",
      "AZURE",
      "GCP",
      "REST APIs",
      "Go"
    ],
    "title": "Neuron"
  },
  {
    "categories": null,
    "contents": "A custom provider of Terraform which helps to perform certain operations on GCP which default provider does not offer.\nThis includes service account key rotation.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/terraform-gcp/",
    "tags": [
      "Terraform",
      "GCP",
      "Go",
      "Golang",
      "terraform-provider",
      "terraform-custom-provider"
    ],
    "title": "Terraform GCP Provider"
  },
  {
    "categories": null,
    "contents": "It is difficult to switch context of different kubernetes clusters hosted in GCP projects. If one has to connect cluster using gcloud, will end up runnig multiple gcloud commands and is painful task.\nYeah GCP has a option of cloud shell, where one can connect to the cluster hassle-free. Its little hard if we have to connect locally from our machines.\nConfig solves exactly the same thing, by letting one to switch the cluster in one command. At a stage it\u0026rsquo;s interactive shell helps one in selection of the cluster they want to switch. As a bonus it also helps in activating service account and switching projects.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/config/",
    "tags": [
      "GoLang",
      "GCP",
      "REST APIs",
      "Go"
    ],
    "title": "Config"
  },
  {
    "categories": null,
    "contents": " There is no native Helm way of identifying the drifts in the releases deployed via Helm.  Now we have a Helm plugin to identify the drifts from the Helm releases deployed in the cluster. https://artifacthub.io/packages/helm-plugin/helm-drift/drift  Just to share context on why this was created. We do in-place edits of resources a lot of times but forget to add the value back to the codebase; these edits go unnoticed and get overridden in the next deployment, which might screw up the environment if the edited changes are required.  In-place edits should be avoided at all costs, but there are a lot more situations where they cannot be avoided.  Once, during our production release, the deployment screwed up the setup due to the same mistake of not adding values back to the helm chart code base.  Why the helm-drift plugin when we have helm-diff? Helm diff will identify the drifts in the state of the helm charts maintained in Kubernetes, but it is not designed to identify the in-place edits.  On the other hand, this helm-drift plugin, with the help of \"kubectl diff,\" will identify the drifts by validating every resource against Kubernetes. To keep it simple, invoking this plugin is as good as rendering the charts and running \"kubectl diff\" for every template in the helm charts.  The newer version of the helm-diff plugin has support for --three-way-merge, which does the job for us, but it does not say anything about how the change was made, whether the patch was applied from the client-side (kubectl) or some controller doing it. But the Kubectl diff helps shed light on these aspects.  This plugin will do the heavy lifting of rendering the templates from the deployed releases or the local chart as per the selection and validating them.  The plugin does have some caveats, which I have called out in the README. Try this on your projects and share feedback. With more feedback, the plugin can grow a lot better.  ",
    "permalink": "https://nikhilsbhat.github.io/blog/helm-drift/",
    "tags": [
      "Helm",
      "Go",
      "Golang",
      "Infrastructure",
      "Helm-Plugins",
      "Helm-Extensions",
      "Helm-Drift",
      "Drift",
      "Registry"
    ],
    "title": "Identifying drifts from deployed helm releases"
  },
  {
    "categories": null,
    "contents": " This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml\n[outputs] home = [\u0026quot;HTML\u0026quot;, \u0026quot;JSON\u0026quot;]  Searching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category\n... \u0026quot;contents\u0026quot;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026quot;tags\u0026quot;:{{ .Params.tags | jsonify }}{{end}}, \u0026quot;categories\u0026quot; : {{ .Params.categories | jsonify }}, ...  Edit fuse.js options to Search static/js/search.js\nkeys: [ \u0026quot;title\u0026quot;, \u0026quot;contents\u0026quot;, \u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot; ]  ",
    "permalink": "https://nikhilsbhat.github.io/search/",
    "tags": null,
    "title": "Search Results"
  },
  {
    "categories": null,
    "contents": "Command-line interface for GoCD that helps in interacting with GoCD server.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/gocd-cli/",
    "tags": [
      "GoCD",
      "Go",
      "Golang",
      "Infrastructure",
      "CI-CD",
      "continuous-delivery",
      "cli",
      "continuous-integration",
      "command-line"
    ],
    "title": "Commandline interface for GoCD server"
  },
  {
    "categories": null,
    "contents": " This Library could be helpful while building any tools around GoCD or while interacting with GoCD to perform certain daily activities. Which could include checking the health of all agents connected to GoCD or status of a job and many more. ",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/gocd-sdk-golang/",
    "tags": [
      "GoCD",
      "Go",
      "Golang",
      "Infrastructure",
      "GoCD-API",
      "API",
      "GoCD-Server",
      "SDK",
      "Client-Library",
      "GoCD-SDK-GO"
    ],
    "title": "GoCD Golang SDK"
  },
  {
    "categories": null,
    "contents": " Prometheus exporter that helps in collecting various metadata and other information from GoCD and exposes it as metrics. This interacts with GoCD server's api to collect metrics, also monitors pipeline directories specified when deployed in GoCD server. It schedules both metric collections from GoCD server and pipeline size as cron to reduce resource spike when /metrics is invoked. Most importantly disk check is an expensive operation which can spike resource consumption, by doing this way load on the platform exporter is running can be reduced. ",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/gocd-prometheus-exporter/",
    "tags": [
      "GoCD",
      "Go",
      "Golang",
      "Infrastructure",
      "Prometheus",
      "Prometheus-exporter",
      "GoCD-Server",
      "Kubernetes"
    ],
    "title": "GoCD prometheus exporter"
  },
  {
    "categories": null,
    "contents": "A terraform provider for GoCD that helps in performing tasks on GoCD server.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/terraform-provider-gocd/",
    "tags": [
      "Terraform",
      "Go",
      "Golang",
      "Infrastructure",
      "CI-CD",
      "continuous-delivery",
      "continuous-integration",
      "command-line",
      "GoCD",
      "k3s",
      "terraform-provider",
      "terraform-custom-provider"
    ],
    "title": "GoCD Terraform Provider"
  },
  {
    "categories": null,
    "contents": " The helm plugin that helps in identifying deviations(mostly due to in-place edits) in the configurations that are deployed via helm chart. Kubernetes' resources can be deployed via package manager helm, it is easier to deploy but to manage the same require more effort.  If helm is used, strictly all resources should be managed by helm itself, but there are places where manual interventions are needed. This results in configuration drift from helm charts deployed. These changes can be overridden by next helm release, what if the required changes are lost before adding it back to helm chart?  This helm plugin is intended to solve the same problem by validating the resources that are part of appropriate chart/release against kubernetes.  This leverages kubectl diff to identify the drifts.  ",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/helm-drift/",
    "tags": [
      "Helm",
      "Go",
      "Golang",
      "Infrastructure",
      "Helm-Plugins",
      "Helm-Extensions",
      "Helm-Drift",
      "Drift",
      "Registry"
    ],
    "title": "Helm Drift"
  },
  {
    "categories": null,
    "contents": " Identifying all images just before the deployment of the helm chart is not a straightforward task.  To make it simple, the helm plugin is leveraged. This can be installed as an add-on to the helm.  It helps in filtering images based on the Kubernetes type. It also helps in filtering images based on a registry which it is part of.  ",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/helm-images/",
    "tags": [
      "Helm",
      "Go",
      "Golang",
      "Infrastructure",
      "Helm-Plugins",
      "Helm-Extensions",
      "Helm-Images",
      "Images",
      "Registry"
    ],
    "title": "Helm Images"
  },
  {
    "categories": null,
    "contents": "A terraform provider support for k3d, which helps in performing all operation that k3d does.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/terraform-provider-k3d/",
    "tags": [
      "Terraform",
      "Go",
      "Golang",
      "Infrastructure",
      "rancher",
      "k3d",
      "docker",
      "containerd",
      "k3s",
      "terraform-provider",
      "terraform-custom-provider"
    ],
    "title": "k3d Terraform Provider"
  },
  {
    "categories": null,
    "contents": "Terraform is one of the best software available to automate the infrastructure and no procrastination in accepting that.\nExtending terraform would help in solving more complexities. Terragen generates defined templates to ease the creation of terraform custom provider which will help in extending terraform.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/terragen/",
    "tags": [
      "Terraform",
      "Go",
      "Infrastructure"
    ],
    "title": "Terragen"
  },
  {
    "categories": null,
    "contents": "This the backbone of neuron cli and is responsible for conneccting to various cloud from a single cloud.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/neuron-cloudy/",
    "tags": [
      "GoLang",
      "AWS",
      "AZURE",
      "GCP",
      "REST APIs",
      "Go"
    ],
    "title": "Neuron Cloudy"
  },
  {
    "categories": null,
    "contents": "In the current era of Devops, with the growing list of tools which one have to deal with to automate the day to day tasks in their respective projects is quite challenging.\nLearning new cloud platform brings in its own challenges with it, one has to learn its natvie terminologies of calling the same resurce. Seeing all these started working on Neuron.\nNo need to know the names of the resources in different cloud. Single tool which can provision cloud resources as per the requirement.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/neuron/",
    "tags": [
      "GoLang",
      "AWS",
      "AZURE",
      "GCP",
      "REST APIs",
      "Go"
    ],
    "title": "Neuron"
  },
  {
    "categories": null,
    "contents": "A custom provider of Terraform which helps to perform certain operations on GCP which default provider does not offer.\nThis includes service account key rotation.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/terraform-gcp/",
    "tags": [
      "Terraform",
      "GCP",
      "Go",
      "Golang",
      "terraform-provider",
      "terraform-custom-provider"
    ],
    "title": "Terraform GCP Provider"
  },
  {
    "categories": null,
    "contents": "It is difficult to switch context of different kubernetes clusters hosted in GCP projects. If one has to connect cluster using gcloud, will end up runnig multiple gcloud commands and is painful task.\nYeah GCP has a option of cloud shell, where one can connect to the cluster hassle-free. Its little hard if we have to connect locally from our machines.\nConfig solves exactly the same thing, by letting one to switch the cluster in one command. At a stage it\u0026rsquo;s interactive shell helps one in selection of the cluster they want to switch. As a bonus it also helps in activating service account and switching projects.\n",
    "permalink": "https://nikhilsbhat.github.io/projects/creations/config/",
    "tags": [
      "GoLang",
      "GCP",
      "REST APIs",
      "Go"
    ],
    "title": "Config"
  },
  {
    "categories": null,
    "contents": " There is no native Helm way of identifying the drifts in the releases deployed via Helm.  Now we have a Helm plugin to identify the drifts from the Helm releases deployed in the cluster. https://artifacthub.io/packages/helm-plugin/helm-drift/drift  Just to share context on why this was created. We do in-place edits of resources a lot of times but forget to add the value back to the codebase; these edits go unnoticed and get overridden in the next deployment, which might screw up the environment if the edited changes are required.  In-place edits should be avoided at all costs, but there are a lot more situations where they cannot be avoided.  Once, during our production release, the deployment screwed up the setup due to the same mistake of not adding values back to the helm chart code base.  Why the helm-drift plugin when we have helm-diff? Helm diff will identify the drifts in the state of the helm charts maintained in Kubernetes, but it is not designed to identify the in-place edits.  On the other hand, this helm-drift plugin, with the help of \"kubectl diff,\" will identify the drifts by validating every resource against Kubernetes. To keep it simple, invoking this plugin is as good as rendering the charts and running \"kubectl diff\" for every template in the helm charts.  The newer version of the helm-diff plugin has support for --three-way-merge, which does the job for us, but it does not say anything about how the change was made, whether the patch was applied from the client-side (kubectl) or some controller doing it. But the Kubectl diff helps shed light on these aspects.  This plugin will do the heavy lifting of rendering the templates from the deployed releases or the local chart as per the selection and validating them.  The plugin does have some caveats, which I have called out in the README. Try this on your projects and share feedback. With more feedback, the plugin can grow a lot better.  ",
    "permalink": "https://nikhilsbhat.github.io/blog/helm-drift/",
    "tags": [
      "Helm",
      "Go",
      "Golang",
      "Infrastructure",
      "Helm-Plugins",
      "Helm-Extensions",
      "Helm-Drift",
      "Drift",
      "Registry"
    ],
    "title": "Identifying drifts from deployed helm releases"
  },
  {
    "categories": null,
    "contents": " This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml\n[outputs] home = [\u0026quot;HTML\u0026quot;, \u0026quot;JSON\u0026quot;]  Searching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category\n... \u0026quot;contents\u0026quot;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026quot;tags\u0026quot;:{{ .Params.tags | jsonify }}{{end}}, \u0026quot;categories\u0026quot; : {{ .Params.categories | jsonify }}, ...  Edit fuse.js options to Search static/js/search.js\nkeys: [ \u0026quot;title\u0026quot;, \u0026quot;contents\u0026quot;, \u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot; ]  ",
    "permalink": "https://nikhilsbhat.github.io/search/",
    "tags": null,
    "title": "Search Results"
  }
]